/////////////////////////////////////////////////////////////////////////////
// Name:        crumbsviewer_frame.cpp
// Purpose:     
// Author:      RAGO
// Modified by: 
// Created:     Sat 22 Mar 18:48:22 2014
// RCS-ID:      
// Copyright:   (C) 2014 crumbssoftware.com
// Licence:     
/////////////////////////////////////////////////////////////////////////////

// Generated by DialogBlocks (Personal Edition), Sat 22 Mar 18:48:22 2014

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

////@begin includes
////@end includes
#include <wx/stdpaths.h>
#include <wx/fileconf.h>
#include <wx/progdlg.h>
#include <wx/filename.h>
#include <wx/dirdlg.h>
#include <wx/dir.h>
#include <wx/aboutdlg.h>
#include <wx/choicdlg.h>
#include <wx/stopwatch.h>
#include "crumbsviewer_frame.h"
#include "CRSystemUtils.h"
#include"cvfilelisttool.h"
#include <iostream>
#include <sstream>


////@begin XPM images
////@end XPM images


file_element * CVTable::pGetFileInfoPDF(long nIndex)
{
    file_element *pElement = NULL;
    
    if(nIndex == -1)
    {
        nIndex = m_nDocumentCurrent;
    }
    
    if(nIndex>=0 && nIndex<m_vFilesPDF.size())
    {
        pElement = &m_vFilesPDF[nIndex];
    }

    
    return pElement;
}

file_element * CVTable::pGetFileInfoTXT(long nIndex)
{
    file_element *pElement = NULL;
    
    if(nIndex == -1)
    {
        nIndex = m_nDocumentCurrent;
    }
    
    if(nIndex>=0 && nIndex<m_vFilesTXT.size())
    {
        pElement = &m_vFilesTXT[nIndex];
    }
    
    
    return pElement;
}

void CVTable::vSetCurrent(long lNewValue, bool bRelative)
{
    if(bRelative)
    {
        m_nDocumentCurrent += lNewValue;
    }
    else
    {
        m_nDocumentCurrent = lNewValue;
    }
    
    if(m_nDocumentCurrent < m_nDocumentFirst)
    {
        m_nDocumentCurrent = m_nDocumentFirst;
    }
    if(m_nDocumentCurrent > m_nDocumentLast)
    {
        m_nDocumentCurrent = m_nDocumentLast;
        
    }
    
}

void CVCollection::vClear()
{
    m_vItems.clear();
    m_sComment.clear();
}

bool CVCollection::bAddItem(collection_item & tItem)
{
    m_vItems.push_back(tItem);
    
    return true;
    
}

bool CVCollection::bSetTableTo(int nNewTable, bool bOnlyMissing)
{
    int ii;
    int nCount = (int)m_vItems.size();
    
    for(ii=0; ii<nCount; ii++)
    {
        if(!bOnlyMissing || m_vItems[ii].nTable==-1)
        {
            m_vItems[ii].nTable = nNewTable;
        }
    }
    
    return true;
}

collection_item * CVCollection::pGetItem(int nIndex)
{
    collection_item *pItem = NULL;
    if(nIndex >=0 && nIndex < m_vItems.size() )
    {
        pItem = &m_vItems[nIndex];
    }
    return pItem;
}

std::string CVCollection::sToString()
{
    //convert everything to string
    //comment
    // # elements
    // db, number
   // wxString xOutput
    
    std::stringstream ss;
    
    ss << "[[" <<m_sComment <<"]] \n";
    
    int ii;
    int nCount = (int)m_vItems.size();
    
    ss << nCount <<"|";
    
    for(ii=0; ii< nCount; ii++)
    {
        ss << m_vItems[ii].nTable <<" | ";
        ss << m_vItems[ii].lIndex <<" |\n";
    }
    
    
    return ss.str();
    
    
}

void CVCollection::vInitFromString(std::string & sInput)
{
    vClear();
    
    std::string sTemp ="[[";
    size_t nSize = sInput.size();// characters!
    size_t pos, pos2, pos_current;
    pos = sInput.find(sTemp);
    pos_current = pos;
    
    if(pos != std::string::npos)
    {
        pos +=2; //advance the size of marker.
        pos_current = pos;
        sTemp = "]]";
        pos2 = sInput.find(sTemp,pos);
        
        if( pos2 != std::string::npos)
        {
            pos_current = pos2+2;//two extra!
            size_t len=pos2-pos;
            std::string sComment = sInput.substr(pos,len);
            
            m_sComment = sComment;
        }
    }
    
    
    std::vector<int> vNumbers;
    //now iterate and find all the numbers and spaces.
    sTemp = "|";
    pos2=sInput.find(sTemp,pos_current);
    while(pos2 !=std::string::npos)
    {
        size_t len=pos2-pos_current;
        if(len>0)
        {
            std::string sToken = sInput.substr(pos_current,len);
            
            int nTemp = atoi(sToken.c_str());
//            bAddPage(nTemp);
//            bStatus = true;
            vNumbers.push_back(nTemp);
        }
        
        pos_current = pos2+1; //advance 1
        pos2=sInput.find(sTemp,pos_current);
    }
    
    //decipher
    int nNumberSize = (int)vNumbers.size();
    int nCountExpected = 0;
    int nCountActual = 0;
    if(nNumberSize > 0 )
    {
         nCountExpected = vNumbers[0];
        
        //test
        for(int ii = 1; ii<nNumberSize; ii += 2)
        {
            collection_item tItem;
            tItem.nTable = vNumbers[ii];
            
            if(ii+1<nNumberSize)
            {
                tItem.lIndex = vNumbers[ii+1];
                
                bAddItem(tItem);
                nCountActual++;
            }
        }
        
    }
    
    printf(" just added %d items to collection\n", nCountActual);
    if(nCountExpected != nCountActual)
    {
        printf("Warning, expected %d items, got %d in collection\n", nCountExpected, nCountActual);
    }


    
}


/*
 * CrumbsViewer_Frame type definition
 */

IMPLEMENT_CLASS( CrumbsViewer_Frame, wxFrame )


/*
 * CrumbsViewer_Frame event table definition
 */

BEGIN_EVENT_TABLE( CrumbsViewer_Frame, wxFrame )

////@begin CrumbsViewer_Frame event table entries
    EVT_BUTTON( ID_CRUMBS_BUTTON_SEARCH_HELP, CrumbsViewer_Frame::OnCrumbsButtonSearchHelpClick )
    EVT_BUTTON( ID_CRUMBS_BUTTON_CLEAR_SEARCH, CrumbsViewer_Frame::OnCrumbsButtonClearSearchClick )
    EVT_BUTTON( ID_CRUMBS_BUTTON_SEARCH, CrumbsViewer_Frame::OnCrumbsButtonSearchClick )
    EVT_BUTTON( ID_CRUMBS_BUTTON_ALL_SEARCH_TABLES, CrumbsViewer_Frame::OnCrumbsButtonAllSearchTablesClick )
    EVT_BUTTON( ID_CRUMBS_BUTTON_CLEAR_SEARCH_TABLES, CrumbsViewer_Frame::OnCrumbsButtonClearSearchTablesClick )
    EVT_COMBOBOX( ID_CRUMBS_COMBO_PREVIOUS_SEARCH, CrumbsViewer_Frame::OnCrumbsComboPreviousSearchSelected )
    EVT_LISTBOX( ID_CRUMBS_LISTBOX_COLLECTION, CrumbsViewer_Frame::OnCrumbsListboxCollectionSelected )
    EVT_BUTTON( ID_CRUMBS_BUTTON_RESULTS_FIRST, CrumbsViewer_Frame::OnCrumbsButtonResultsFirstClick )
    EVT_BUTTON( ID_CRUMBS_BUTTON_RESULTS_PREV, CrumbsViewer_Frame::OnCrumbsButtonResultsPrevClick )
    EVT_BUTTON( ID_CRUMBS_BUTTON_RESULTS_NEXT, CrumbsViewer_Frame::OnCrumbsButtonResultsNextClick )
    EVT_BUTTON( ID_CRUMBS_BUTTON_RESULTS_LAST, CrumbsViewer_Frame::OnCrumbsButtonResultsLastClick )
    EVT_BUTTON( ID_CRUMBS_BUTTON_VIEW_FIRST, CrumbsViewer_Frame::OnCrumbsButtonViewFirstClick )
    EVT_BUTTON( ID_CRUMBS_BUTTON_VIEW_PREV, CrumbsViewer_Frame::OnCrumbsButtonViewPrevClick )
    EVT_TEXT_ENTER( ID_TEXTCTRL, CrumbsViewer_Frame::OnTextctrlViewEnter )
    EVT_BUTTON( ID_CRUMBS_BUTTON_VIEW_NEXT, CrumbsViewer_Frame::OnCrumbsButtonViewNextClick )
    EVT_BUTTON( ID_CRUMBS_BUTTON_VIEW_LAST, CrumbsViewer_Frame::OnCrumbsButtonViewLastClick )
    EVT_COMBOBOX( ID_COMBOBOX, CrumbsViewer_Frame::OnComboboxWebViewSelected )
    EVT_BUTTON( ID_CRUMBS_BUTTON_TEST, CrumbsViewer_Frame::OnCrumbsButtonTestClick )
    EVT_MENU( ID_CRUMBS_MENU_DATABASE_BUILD_DB, CrumbsViewer_Frame::OnCrumbsMenuDatabaseBuildDbClick )
    EVT_MENU( ID_CRUMBS_MENU_DATABASE_CREATE_PACKAGE, CrumbsViewer_Frame::OnCrumbsMenuDatabaseCreatePackageClick )
    EVT_MENU( ID_CRUMBS_MENU_DATABASE_LOAD_UPDATE, CrumbsViewer_Frame::OnCrumbsMenuDatabaseLoadUpdateClick )
    EVT_MENU( wxID_ABOUT, CrumbsViewer_Frame::OnAboutClick )
    EVT_MENU( ID_MENUITEM_SEARCH_HELP, CrumbsViewer_Frame::OnMenuitemSearchHelpClick )
    EVT_MENU( ID_MENUITEM_FILETOOLS_LIST_CONSECUTIVE, CrumbsViewer_Frame::OnMenuitemFiletoolsListConsecutiveClick )
////@end CrumbsViewer_Frame event table entries

END_EVENT_TABLE()


/*
 * CrumbsViewer_Frame constructors
 */

CrumbsViewer_Frame::CrumbsViewer_Frame()
{
    Init();
}

CrumbsViewer_Frame::CrumbsViewer_Frame( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{
    Init();
    Create( parent, id, caption, pos, size, style );
}


/*
 * CrumbsViewer_Frame creator
 */

bool CrumbsViewer_Frame::Create( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{
////@begin CrumbsViewer_Frame creation
    wxFrame::Create( parent, id, caption, pos, size, style );

    CreateControls();
    if (GetSizer())
    {
        GetSizer()->SetSizeHints(this);
    }
    Centre();
////@end CrumbsViewer_Frame creation
    return true;
}


/*
 * CrumbsViewer_Frame destructor
 */

CrumbsViewer_Frame::~CrumbsViewer_Frame()
{
////@begin CrumbsViewer_Frame destruction
////@end CrumbsViewer_Frame destruction
    
    if(m_frameSearchHelp != NULL)
	{ m_frameSearchHelp->Destroy();
        delete m_frameSearchHelp;
	}
}


/*
 * Member initialisation
 */

void CrumbsViewer_Frame::Init()
{
////@begin CrumbsViewer_Frame member initialisation
    m_textcontrolSearch = NULL;
    m_checkListBoxSearchDB = NULL;
    m_comboSearchLimit = NULL;
    m_comboPreviousSearch = NULL;
    m_textctrlCollectionComment = NULL;
    m_listboxResults = NULL;
    m_buttonViewFirst = NULL;
    m_textViewCurent = NULL;
    m_buttonViewLast = NULL;
    m_comboViewCurrentTable = NULL;
    m_webDocument = NULL;
////@end CrumbsViewer_Frame member initialisation
    m_frameSearchHelp = NULL;
    
    m_xsProgramPath = wxGetCwd();
    
    vLoadFromIniFile(INI_FILE);

    wxString xsMessage;
    for(int ii=0; ii<m_vTables.size(); ii++)
    {
        xsMessage.Append( sUpdateTableInfo(m_vTables[ii]) );
    }
    
    wxMessageBox(xsMessage, wxT("Crumbs 2 Viewer -- Loaded Tables"));

    
    //display table info
    
    //check for unapplied updates
    vCheckForLocalUpdates();;
    
}


/*
 * Control creation for CrumbsViewer_Frame
 */

void CrumbsViewer_Frame::CreateControls()
{
    wxWebView *webviewpdf = wxWebView::New(this, ID_CRUMBS_WEB_VIEW,wxWebViewDefaultURLStr,wxDefaultPosition, wxSize(700,900));
    
////@begin CrumbsViewer_Frame content construction
    // Generated by DialogBlocks, Sun 29 Jan 18:02:27 2017 (Personal Edition)

    CrumbsViewer_Frame* itemFrame1 = this;

    wxMenuBar* menuBar = new wxMenuBar;
    wxMenu* itemMenu44 = new wxMenu;
    itemMenu44->Append(ID_CRUMBS_MENU_DATABASE_BUILD_DB, _("Update Database"), wxEmptyString, wxITEM_NORMAL);
    itemMenu44->Append(ID_CRUMBS_MENU_DATABASE_CREATE_PACKAGE, _("Advanced: Create Update Package"), wxEmptyString, wxITEM_NORMAL);
    itemMenu44->Append(ID_CRUMBS_MENU_DATABASE_LOAD_UPDATE, _("Advanced: Apply Update Package"), wxEmptyString, wxITEM_NORMAL);
    menuBar->Append(itemMenu44, _("Database"));
    wxMenu* itemMenu48 = new wxMenu;
    itemMenu48->Append(wxID_ABOUT, _("&About"), wxEmptyString, wxITEM_NORMAL);
    itemMenu48->Append(ID_MENUITEM_SEARCH_HELP, _("Show Search Help"), wxEmptyString, wxITEM_NORMAL);
    menuBar->Append(itemMenu48, _("Help"));
    wxMenu* itemMenu51 = new wxMenu;
    itemMenu51->Append(ID_MENUITEM_FILETOOLS_LIST_CONSECUTIVE, _("List consecutive files"), wxEmptyString, wxITEM_NORMAL);
    menuBar->Append(itemMenu51, _("File Tools"));
    itemFrame1->SetMenuBar(menuBar);

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxHORIZONTAL);
    itemFrame1->SetSizer(itemBoxSizer2);

    wxBoxSizer* itemBoxSizer3 = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer2->Add(itemBoxSizer3, 0, wxGROW|wxALL, 5);

    wxBoxSizer* itemBoxSizer4 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer3->Add(itemBoxSizer4, 0, wxGROW|wxALL, 5);

    wxStaticText* itemStaticText5 = new wxStaticText( itemFrame1, wxID_STATIC, _("Type search here..."), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer4->Add(itemStaticText5, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxButton* itemButton6 = new wxButton( itemFrame1, ID_CRUMBS_BUTTON_SEARCH_HELP, _("Search Help ?"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer4->Add(itemButton6, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_textcontrolSearch = new wxTextCtrl( itemFrame1, ID_CRUMBS_TEXT_SEARCH, wxEmptyString, wxDefaultPosition, wxSize(250, 150), wxTE_MULTILINE|wxTE_PROCESS_ENTER );
    itemBoxSizer3->Add(m_textcontrolSearch, 0, wxGROW|wxALL, 5);

    wxBoxSizer* itemBoxSizer8 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer3->Add(itemBoxSizer8, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxButton* itemButton9 = new wxButton( itemFrame1, ID_CRUMBS_BUTTON_CLEAR_SEARCH, _("Clear"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer8->Add(itemButton9, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxButton* itemButton10 = new wxButton( itemFrame1, ID_CRUMBS_BUTTON_SEARCH, _("Search"), wxDefaultPosition, wxSize(200, -1), 0 );
    itemBoxSizer8->Add(itemButton10, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxBoxSizer* itemBoxSizer11 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer3->Add(itemBoxSizer11, 0, wxGROW|wxALL, 5);

    wxBoxSizer* itemBoxSizer12 = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer11->Add(itemBoxSizer12, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxStaticText* itemStaticText13 = new wxStaticText( itemFrame1, wxID_STATIC, _("Tables"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer12->Add(itemStaticText13, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxButton* itemButton14 = new wxButton( itemFrame1, ID_CRUMBS_BUTTON_ALL_SEARCH_TABLES, _("All"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer12->Add(itemButton14, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxButton* itemButton15 = new wxButton( itemFrame1, ID_CRUMBS_BUTTON_CLEAR_SEARCH_TABLES, _("Clear"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer12->Add(itemButton15, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxBoxSizer* itemBoxSizer16 = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer11->Add(itemBoxSizer16, 1, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxArrayString m_checkListBoxSearchDBStrings;
    m_checkListBoxSearchDB = new wxCheckListBox( itemFrame1, ID_CRUMBS_CHECKLISTBOX_SEARCH_DB, wxDefaultPosition, wxDefaultSize, m_checkListBoxSearchDBStrings, wxLB_MULTIPLE );
    itemBoxSizer16->Add(m_checkListBoxSearchDB, 0, wxGROW|wxALL, 5);

    wxBoxSizer* itemBoxSizer18 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer3->Add(itemBoxSizer18, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxStaticText* itemStaticText19 = new wxStaticText( itemFrame1, wxID_STATIC, _("Max. Results"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer18->Add(itemStaticText19, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxArrayString m_comboSearchLimitStrings;
    m_comboSearchLimitStrings.Add(_("10"));
    m_comboSearchLimitStrings.Add(_("100"));
    m_comboSearchLimitStrings.Add(_("500"));
    m_comboSearchLimitStrings.Add(_("ALL"));
    m_comboSearchLimit = new wxComboBox( itemFrame1, ID_CRUMBS_COMBO_SEARCH_LIMIT, _("500"), wxDefaultPosition, wxDefaultSize, m_comboSearchLimitStrings, wxCB_READONLY );
    m_comboSearchLimit->SetStringSelection(_("500"));
    itemBoxSizer18->Add(m_comboSearchLimit, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxStaticText* itemStaticText21 = new wxStaticText( itemFrame1, wxID_STATIC, _("Previous Searches"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer3->Add(itemStaticText21, 0, wxALIGN_LEFT|wxALL, 5);

    wxArrayString m_comboPreviousSearchStrings;
    m_comboPreviousSearch = new wxComboBox( itemFrame1, ID_CRUMBS_COMBO_PREVIOUS_SEARCH, wxEmptyString, wxDefaultPosition, wxDefaultSize, m_comboPreviousSearchStrings, wxCB_READONLY );
    itemBoxSizer3->Add(m_comboPreviousSearch, 0, wxGROW|wxALL, 5);

    wxStaticText* itemStaticText23 = new wxStaticText( itemFrame1, wxID_STATIC, _("Collection comments"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer3->Add(itemStaticText23, 0, wxALIGN_LEFT|wxALL, 5);

    m_textctrlCollectionComment = new wxTextCtrl( itemFrame1, ID_CRUMBS_TEXT_COLLECTION_COMMENT, wxEmptyString, wxDefaultPosition, wxSize(-1, 70), wxTE_MULTILINE|wxTE_READONLY );
    itemBoxSizer3->Add(m_textctrlCollectionComment, 0, wxGROW|wxALL, 5);

    wxBoxSizer* itemBoxSizer25 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer3->Add(itemBoxSizer25, 1, wxGROW|wxALL, 5);

    wxArrayString m_listboxResultsStrings;
    m_listboxResults = new wxListBox( itemFrame1, ID_CRUMBS_LISTBOX_COLLECTION, wxDefaultPosition, wxDefaultSize, m_listboxResultsStrings, wxLB_SINGLE );
    itemBoxSizer25->Add(m_listboxResults, 1, wxGROW|wxALL, 5);

    wxBoxSizer* itemBoxSizer27 = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer25->Add(itemBoxSizer27, 0, wxALIGN_TOP|wxALL, 5);

    wxButton* itemButton28 = new wxButton( itemFrame1, ID_CRUMBS_BUTTON_RESULTS_FIRST, _("First"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer27->Add(itemButton28, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxButton* itemButton29 = new wxButton( itemFrame1, ID_CRUMBS_BUTTON_RESULTS_PREV, _("Prev"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer27->Add(itemButton29, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    itemBoxSizer27->Add(5, 5, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxButton* itemButton31 = new wxButton( itemFrame1, ID_CRUMBS_BUTTON_RESULTS_NEXT, _("Next"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer27->Add(itemButton31, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxButton* itemButton32 = new wxButton( itemFrame1, ID_CRUMBS_BUTTON_RESULTS_LAST, _("Last"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer27->Add(itemButton32, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxBoxSizer* itemBoxSizer33 = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer2->Add(itemBoxSizer33, 1, wxGROW|wxALL, 5);

    wxBoxSizer* itemBoxSizer34 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer33->Add(itemBoxSizer34, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    m_buttonViewFirst = new wxButton( itemFrame1, ID_CRUMBS_BUTTON_VIEW_FIRST, _("<<"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer34->Add(m_buttonViewFirst, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxButton* itemButton36 = new wxButton( itemFrame1, ID_CRUMBS_BUTTON_VIEW_PREV, _("<"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer34->Add(itemButton36, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_textViewCurent = new wxTextCtrl( itemFrame1, ID_TEXTCTRL, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_PROCESS_ENTER );
    itemBoxSizer34->Add(m_textViewCurent, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxButton* itemButton38 = new wxButton( itemFrame1, ID_CRUMBS_BUTTON_VIEW_NEXT, _(">"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer34->Add(itemButton38, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_buttonViewLast = new wxButton( itemFrame1, ID_CRUMBS_BUTTON_VIEW_LAST, _(">>"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer34->Add(m_buttonViewLast, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxArrayString m_comboViewCurrentTableStrings;
    m_comboViewCurrentTable = new wxComboBox( itemFrame1, ID_COMBOBOX, wxEmptyString, wxDefaultPosition, wxDefaultSize, m_comboViewCurrentTableStrings, wxCB_READONLY );
    itemBoxSizer34->Add(m_comboViewCurrentTable, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxButton* itemButton41 = new wxButton( itemFrame1, ID_CRUMBS_BUTTON_TEST, _("Test"), wxDefaultPosition, wxDefaultSize, 0 );
    itemButton41->Show(false);
    itemBoxSizer34->Add(itemButton41, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_webDocument = (wxWebView*) FindWindow(ID_CRUMBS_WEB_VIEW);
    wxASSERT( m_webDocument != NULL );
    itemBoxSizer33->Add(m_webDocument, 1, wxGROW|wxALL, 5);

////@end CrumbsViewer_Frame content construction
    
    
    m_frameSearchHelp = new CVSearchHelp_frame(this, wxID_ANY);
    //add to the combo box the databases
    for(int ii=0; ii<m_vTables.size(); ii++)
    {
        m_comboViewCurrentTable->Append(m_vTables[ii].xsTableName);
//ggg        m_comboSearchDB->Append(m_vTables[ii].xsTableName);
        m_checkListBoxSearchDB->Append(m_vTables[ii].xsTableName);
        m_checkListBoxSearchDB->Check(ii, true);
    }
    
//ggg    //add option ALL TABLES
//    if(m_vTables.size()>0)
//    {
//        m_comboSearchDB->Append(wxT("All Tables"));
//        m_comboSearchDB->SetSelection(0);
//        
//        
//
//    }
    
    m_nCurrentTable = -1; //none
    
    vSetCurrentTable(0);
    vRefreshWebView();
}


/*
 * Should we show tooltips?
 */

bool CrumbsViewer_Frame::ShowToolTips()
{
    return true;
}

/*
 * Get bitmap resources
 */

wxBitmap CrumbsViewer_Frame::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin CrumbsViewer_Frame bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
////@end CrumbsViewer_Frame bitmap retrieval
}

/*
 * Get icon resources
 */

wxIcon CrumbsViewer_Frame::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin CrumbsViewer_Frame icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end CrumbsViewer_Frame icon retrieval
}


void CrumbsViewer_Frame::vLoadFromIniFile(wxString xsFileName)
{
    
    wxString xsCurrentPath = wxGetCwd();
    
	wxFileConfig *myConfig = new wxFileConfig(APPLICATION_NAME,wxEmptyString,
                                              xsFileName, wxEmptyString, wxCONFIG_USE_LOCAL_FILE | wxCONFIG_USE_RELATIVE_PATH);
    
    bool bResult = true;
    int nTableCount=0;
    bResult = bResult & myConfig->Read(INI_KEY_TABLE_COUNT,&nTableCount, 0);
    
//    printf("got %d tables!\n", nTableCount);
    if(nTableCount > 0 )
    {
        
        for(int ii=0; ii<nTableCount; ii++)
        {
            CVTable tTable;
            
            wxString xsKey;
            
            xsKey = wxString::Format(wxT("%s%d/%s"),INI_TABLE_ROOT,ii+1,INI_TABLE_NAME);
            myConfig->Read(xsKey,&tTable.xsTableName, wxT(""));
            
            xsKey = wxString::Format(wxT("%s%d/%s"),INI_TABLE_ROOT,ii+1,INI_TABLE_PATH_PDF);
            myConfig->Read(xsKey,&tTable.xsPathPDF, wxT(""));
            
            xsKey = wxString::Format(wxT("%s%d/%s"),INI_TABLE_ROOT,ii+1,INI_TABLE_PATH_TXT);
            myConfig->Read(xsKey,&tTable.xsPathTXT, wxT(""));
            
            xsKey = wxString::Format(wxT("%s%d/%s"),INI_TABLE_ROOT,ii+1,INI_TABLE_DOC_ROOT);
            myConfig->Read(xsKey,&tTable.xsDocRoot, wxT(""));
            
            xsKey = wxString::Format(wxT("%s%d/%s"),INI_TABLE_ROOT,ii+1,INI_TABLE_DATABASE_TABLE_NAME);
            myConfig->Read(xsKey,&tTable.xsDBTable, wxT(""));
            
            
            m_vTables.push_back(tTable);
            
        }
        

        
    }
    
    myConfig->Read(INI_KEY_DATABASE_FILE,&m_xsDatabaseFileName, wxT("Crumbs2.db3"));

    

    
    
    
    delete myConfig;
    
    
}

void CrumbsViewer_Frame::vSaveToIniFile(wxString xsFileName)
{
	wxFileConfig *myConfig = new wxFileConfig(APPLICATION_NAME,wxEmptyString,
                                              xsFileName, wxEmptyString, wxCONFIG_USE_LOCAL_FILE | wxCONFIG_USE_RELATIVE_PATH);
    
  
    
    
    
	delete myConfig;
}

void CrumbsViewer_Frame::vIniFileAppendUpdatePackage(wxString xsINIFileName, wxString &xsUpdatePackage)
{
    
    wxFileConfig *myConfig = new wxFileConfig(APPLICATION_NAME,wxEmptyString,
                                              xsINIFileName, wxEmptyString, wxCONFIG_USE_LOCAL_FILE | wxCONFIG_USE_RELATIVE_PATH);
    
    
    //find last update (if any)
    
    
    wxString xsKey;
    wxString xsLastUpdate;
    
    
    int nCount = 0;
    while(true)
    {
        
        xsKey = wxString::Format(wxT("%s/%s%d"),INI_UPDATE_ROOT,INI_UPDATE_FILE, nCount);
        
        if( !myConfig->Read(xsKey,&xsLastUpdate, wxT("")) )
        {
            printf("total updates applied = %d",nCount);
            //last one
            break;
        }
        else
        {
            printf("update applied %d: %s\n",nCount, (const char *)xsLastUpdate.mb_str() );
        }
        nCount++;
        
    }
    
    //now, append file
    wxFileName xFile(xsUpdatePackage);
    wxString xsCleanFileName = xFile.GetName();
    
    xsKey = wxString::Format(wxT("%s/%s%d"),INI_UPDATE_ROOT,INI_UPDATE_FILE, nCount);
    myConfig->Write(xsKey, xsCleanFileName);

    
	delete myConfig;

    
}

int CrumbsViewer_Frame::nIniFileCheckUpdatePackageApplied(wxString xsINIFileName, wxString &xsUpdatePackage)
{
    wxFileName xFile(xsUpdatePackage);
    wxString xsCleanFileName = xFile.GetName();

    
    wxFileConfig *myConfig = new wxFileConfig(APPLICATION_NAME,wxEmptyString,
                                              xsINIFileName, wxEmptyString, wxCONFIG_USE_LOCAL_FILE | wxCONFIG_USE_RELATIVE_PATH);
    
    
    //find last update (if any)
    
    
    wxString xsKey;
    wxString xsLastUpdate;
    
    int nIndex = -1;
    
    
    int nCount = 0;
    while(true)
    {
        
        xsKey = wxString::Format(wxT("%s/%s%d"),INI_UPDATE_ROOT,INI_UPDATE_FILE, nCount);
        
        if( !myConfig->Read(xsKey,&xsLastUpdate, wxT("")) )
        {
            //printf("total updates applied = %d",nCount);
            //last one
            break;
        }
        else
        {
            //compare
            if( xsCleanFileName.compare(xsLastUpdate) == 0 )
            {
                //yes.. found!
                nIndex = nCount;
                break;
                printf("update found %d: %s\n",nCount, (const char *)xsLastUpdate.mb_str() );
            }
            
        }
        nCount++;
        
    }
    
    
    
	delete myConfig;

    
    
    
    return nIndex;
    
}

wxString CrumbsViewer_Frame::sUpdateTableInfo(CVTable & tTable)
{
    
    wxString xsMessageReturn;
    
    //walk ALL elements in pdf and get an estimate of Max and Min
    
    //go to start path, and create file list.
    std::stringstream ss;
    std::vector<file_element> vFilesPDF;
    
    std::string sBasePath = std::string(tTable.xsPathPDF.mb_str());
    std::string sExt = "pdf";
//    bCreateFileList(ss, sBasePath, sExt, -1, vFilesPDF); {
    {
        wxString xsCurrentDirectory = wxGetCwd();
        wxString xsBasePath = xsCurrentDirectory + wxFILE_SEP_PATH + tTable.xsPathPDF;
        
        wxStopWatch sw1;
        bCreateFileListV2(ss, std::string(xsBasePath.mb_str()), sExt, -1, vFilesPDF);
        long t1 = sw1.Time();
        
//        std::vector<file_element> vFilesPDF2;
//        wxStopWatch sw2;
//        bCreateFileListV2(ss, std::string(xsBasePath.mb_str()), std::string("PDF"), -1, vFilesPDF2);
//        long t2 = sw2.Time();
        printf("\n\nCreateFileList time: %ld ms", t1);
      //  printf("\n v1: %lu files, v2: %lu files", vFilesPDF.size(), vFilesPDF2.size());
        
//        //COMpare lists
//        for (int kk = 0; kk < vFilesPDF.size() && kk < vFilesPDF2.size(); kk++) {
//            wxString s1(vFilesPDF[kk].sName.c_str(), wxConvUTF8);
//            wxString s2(vFilesPDF2[kk].sName.c_str(), wxConvUTF8);
//            
//            if(s1.CmpNoCase(s2) != 0) {
//                printf("Error [%d]: %s vs %s", kk, (const char*)s1.mb_str().data(), (const char*)s2.mb_str().data());
//            }
//        }
        
    }
    printf("\n found %d pdf files for table: %s\n", (int)vFilesPDF.size(), (const unsigned char*)tTable.xsTableName.c_str());
    xsMessageReturn.Append(wxString::Format(wxT("Found %d pdf files for table: %s\n"), (int)vFilesPDF.size(), tTable.xsTableName));
    //estimate first and last one!
    
    long lMin = 1000000;
    long lMax = 0;
    // walk all,
    // remove the doc root and that  is the index!
    int nFileCount = (int)vFilesPDF.size();
    for(int ii = 0; ii<nFileCount; ii++)
    {
        wxString xsFileName = wxString(vFilesPDF[ii].sName.c_str(), wxConvUTF8);
        
        if(xsFileName.StartsWith(tTable.xsDocRoot))
        {
            //remove n characters then get index number!
            wxString xsNumber = xsFileName.AfterFirst('0');
            long lValue;
            xsNumber.ToLong(&lValue);
            
            if(lValue < lMin)
                lMin = lValue;
            
            if(lValue > lMax)
                lMax = lValue;
            
        }
        
    }
    tTable.m_nDocumentFirst = lMin;
    tTable.m_nDocumentLast = lMax;
    tTable.m_nDocumentCurrent = lMin;
    
    //now, do a file array  in order in this table!
    tTable.m_vFilesPDF.clear();
    
    tTable.m_vFilesPDF.resize(lMax+1);
    //now, walk again the list and assign to the right index!
    
    for(int ii = 0; ii<nFileCount; ii++)
    {
        wxString xsFileName = wxString(vFilesPDF[ii].sName.c_str(), wxConvUTF8);
        
        if(xsFileName.StartsWith(tTable.xsDocRoot))
        {
            //remove n characters then get index number!
            wxString xsNumber = xsFileName.AfterFirst('0');
            long lValue;
            xsNumber.ToLong(&lValue);
            

            if(lValue>=0 &&  lValue < tTable.m_vFilesPDF.size() )
            {
                tTable.m_vFilesPDF[lValue] = vFilesPDF[ii];
            }
        }
        
    }

    
    printf(" Min = %ld,  max = %ld\n", lMin, lMax);
    xsMessageReturn.Append(wxString::Format(wxT(" Min = %ld,  max = %ld\n"), lMin, lMax));
    
    //now, do the same for text files
    std::vector<file_element> vFilesTXT;
    
    sBasePath = std::string(tTable.xsPathTXT.mb_str());
    sExt = "txt";
    bCreateFileListV2(ss, sBasePath, sExt, -1, vFilesTXT);
    
    printf(" found %d txt files for table: %s\n", (int)vFilesTXT.size(), (const unsigned char*)tTable.xsTableName.c_str());
    xsMessageReturn.Append(wxString::Format(wxT(" Found %d txt files for table: %s\n"), (int)vFilesTXT.size(), tTable.xsTableName));
    //now add them in order to the file array
    //now, do a file array  in order in this table!
    tTable.m_vFilesTXT.clear();
    
    tTable.m_vFilesTXT.resize(lMax+1);
    //now, walk again the list and assign to the right index!
    
    for(int ii = 0; ii<nFileCount; ii++)
    {
        wxString xsFileName = wxString(vFilesTXT[ii].sName.c_str(), wxConvUTF8);
        
        if(xsFileName.StartsWith(tTable.xsDocRoot))
        {
            //remove n characters then get index number!
            wxString xsNumber = xsFileName.AfterFirst('0');
            long lValue;
            xsNumber.ToLong(&lValue);
            
            
            if(lValue>=0 &&  lValue < tTable.m_vFilesTXT.size() )
            {
                tTable.m_vFilesTXT[lValue] = vFilesTXT[ii];
            }
        }
        
    }


    return xsMessageReturn;
    
}


void CrumbsViewer_Frame::vSetCurrentTable(int nTable)
{
    if(nTable>=0 && nTable<m_vTables.size())
    {
        m_nCurrentTable = nTable;
        m_comboViewCurrentTable->SetSelection(nTable);
        
        //vRefreshWebView();
        
    }

}
CVTable * CrumbsViewer_Frame::pGetTable(int nTableIndex)
{
    CVTable *pTable = NULL;
    
    if(nTableIndex == -1)
    {
        nTableIndex = m_nCurrentTable;
    }
    
    if(nTableIndex >=0 && nTableIndex < m_vTables.size() )
    {
        pTable = &m_vTables[nTableIndex];
    }
    
    return pTable;
}

void CrumbsViewer_Frame::vRefreshWebView()
{
    
    //get current table
    //update navigation
    //update webview
    
    CVTable *pTable = pGetTable(-1);
    
    
    if(pTable != NULL)
    {
        
        m_buttonViewFirst->SetLabel(wxString::Format(wxT("%ld<<"),pTable->m_nDocumentFirst));
        m_buttonViewLast->SetLabel(wxString::Format(wxT(">>%ld"),pTable->m_nDocumentLast));

        m_textViewCurent->SetValue(wxString::Format(wxT("%ld"),pTable->m_nDocumentCurrent));
        
        //get current document and show it!!
        file_element *pElement = pTable->pGetFileInfoPDF(-1 ); //current document!
        
        if(pElement != NULL)
        {
            wxString xsURL = wxString(pElement->sFullPath.c_str(), wxConvUTF8 );
            
            wxFileName xsFileNameURL(xsURL);
            
            //if it is relative, get current path and prepend it
            if(xsFileNameURL.IsRelative())
            {
                xsURL = m_xsProgramPath + wxFILE_SEP_PATH + xsURL;
            }
            
            m_webDocument->LoadURL(xsURL);
        }
    }
}

void CrumbsViewer_Frame::vSetNewPage(int nTable, long lIndex)
{
    
    vSetCurrentTable(nTable);
    
    CVTable *pTable = pGetTable(nTable);
    
    if(pTable != NULL)
    {
        pTable->vSetCurrent(lIndex, false);
        vRefreshWebView();
    }
}


/*
 * wxEVT_COMMAND_COMBOBOX_SELECTED event handler for ID_COMBOBOX
 */

void CrumbsViewer_Frame::OnComboboxWebViewSelected( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_COMBOBOX_SELECTED event handler for ID_COMBOBOX in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_COMBOBOX_SELECTED event handler for ID_COMBOBOX in CrumbsViewer_Frame.
    
    //get selection
    int nSel = event.GetSelection();
    vSetCurrentTable(nSel);
    vRefreshWebView();
}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_VIEW_FIRST
 */

void CrumbsViewer_Frame::OnCrumbsButtonViewFirstClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_VIEW_FIRST in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_VIEW_FIRST in CrumbsViewer_Frame.
    
    CVTable *pTable = pGetTable(-1);
    
    
    if(pTable != NULL)
    {
        pTable->vSetCurrent(pTable->m_nDocumentFirst, false);
        vRefreshWebView();

    }
    
}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_VIEW_PREV
 */

void CrumbsViewer_Frame::OnCrumbsButtonViewPrevClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_VIEW_PREV in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_VIEW_PREV in CrumbsViewer_Frame.
    CVTable *pTable = pGetTable(-1);
    
    
    if(pTable != NULL)
    {
        pTable->vSetCurrent(-1, true);
        vRefreshWebView();
        
    }

}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_VIEW_NEXT
 */

void CrumbsViewer_Frame::OnCrumbsButtonViewNextClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_VIEW_NEXT in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_VIEW_NEXT in CrumbsViewer_Frame.
    CVTable *pTable = pGetTable(-1);
    
    
    if(pTable != NULL)
    {
        pTable->vSetCurrent(1, true);
        vRefreshWebView();
        
    }

}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_VIEW_LAST
 */

void CrumbsViewer_Frame::OnCrumbsButtonViewLastClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_VIEW_LAST in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_VIEW_LAST in CrumbsViewer_Frame.
    
    
    CVTable *pTable = pGetTable(-1);
    
    
    if(pTable != NULL)
    {
        pTable->vSetCurrent(pTable->m_nDocumentLast, false);
        vRefreshWebView();
        
    }

}



/*
 * wxEVT_COMMAND_TEXT_ENTER event handler for ID_TEXTCTRL
 */

void CrumbsViewer_Frame::OnTextctrlViewEnter( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_TEXT_ENTER event handler for ID_TEXTCTRL in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_TEXT_ENTER event handler for ID_TEXTCTRL in CrumbsViewer_Frame.
    
    int nNewIndex = wxAtoi(event.GetString());
    
    CVTable *pTable = pGetTable(-1);
    
    
    if(pTable != NULL)
    {
        pTable->vSetCurrent(nNewIndex, false);
        vRefreshWebView();
        
    }

}

static int sqlite_callback(void *NotUsed, int argc, char **argv, char **azColName){
    int i;
    for(i=0; i<argc; i++){
        printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
    }
    printf("\n");
    return 0;
}



static int sqlite_callback_collection(void *pCollection, int argc, char **argv, char **azColName)
{
    int i;
    
    collection_item tItem;
    tItem.nTable = -1; //no idea where it came from, fix that later.
    tItem.lIndex = -1;
 //ee   printf(" Total columns = %d\n",argc);
    for(i=0; i<argc; i++)
    {
     //ee   printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
        
        if(argv[i]) //not null
        {
            if(strcmp(azColName[i], "ID") == 0 )
            {
                tItem.lIndex = atoi(argv[i]);
            }
        }
        
    }
 //ee   printf("\n");
    
    if(pCollection != NULL && tItem.lIndex > -1)
    {
        ((CVCollection*)pCollection )->bAddItem(tItem);
    }
    return 0;
}


//get integer of first non null result
static int sqlite_callback_getinteger(void *pInteger, int argc, char **argv, char **azColName)
{
    int i;
    *((int*)pInteger)  = 0;
    for(i=0; i<argc; i++)
    {
        if(argv[i]) //not null
        {
            {
                if(pInteger!= NULL)
                {
                    *((int*)pInteger) = atoi(argv[i]);
                }
                
            }
        }
        
    }
    return 0;
}

static int sqlite_callback_increaseinteger(void *pInteger, int argc, char **argv, char **azColName)
{
    if(argc>0)
    {
        if(pInteger!= NULL)
        {
            (*((int*)pInteger))++; //increase
        }
        
    }
    return 0;
}




/*
 * wxEVT_COMMAND_MENU_SELECTED event handler for ID_CRUMBS_MENU_DATABASE_BUILD_DB
 */

void CrumbsViewer_Frame::OnCrumbsMenuDatabaseBuildDbClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_MENU_SELECTED event handler for ID_CRUMBS_MENU_DATABASE_BUILD_DB in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_MENU_SELECTED event handler for ID_CRUMBS_MENU_DATABASE_BUILD_DB in CrumbsViewer_Frame.
    
    //experiment with sqlite build database!!
    // Pick Table of interest.
    // walk and consume all txt, add to DB tables for search.
//opening db
    
    
    int nTableIndex = m_nCurrentTable;
    
    wxArrayString tOptions;
    for(int ii=0; ii<m_vTables.size(); ii++)
    {
        CVTable *pTable = pGetTable(ii);
        
        wxString xsOption = wxT("---");
        if(pTable != NULL)
        {
            xsOption  = pTable->xsTableName;
        }
        
        tOptions.Add(xsOption);
        
    }
    
    if(m_vTables.size()>0)
    {
        tOptions.Add(wxT("All Tables"));
    }

    
    nTableIndex  = wxGetSingleChoiceIndex(wxT("Choose table to update"), wxT("choose table"), tOptions, m_nCurrentTable);
  
    if (nTableIndex < 0) {
        wxMessageBox(wxT("Update canceled by user"));
        return;
    }
    wxArrayString tUpdateOptions;
    tUpdateOptions.Add(wxT("Update New Items"));
    tUpdateOptions.Add(wxT("Updete ALL Items"));
    int updateOption = wxGetSingleChoiceIndex(wxT("Choose update option"), wxT("choose table"), tUpdateOptions, 0);

    if (updateOption < 0) {
        wxMessageBox(wxT("Update canceled by user"));
    } else {
        bool bUpdateOnlyMissing = false;
        if (updateOption == 0) {
            bUpdateOnlyMissing = true;
        }
        
        wxDateTime xDateAnchor(1,wxDateTime::Month::Jan,2000);
        
        wxString xsMessage;
        if(nTableIndex < m_vTables.size() )
        {
            xsMessage.Append( sUpdateTableInfo(m_vTables[nTableIndex]) );
            xsMessage.Append( sDatabaseUpdateTables(nTableIndex,xDateAnchor, bUpdateOnlyMissing));
        }
        else
        {   //search in all tables!
            for(int ii=0; ii<m_vTables.size(); ii++)
            {
                xsMessage.Append( sUpdateTableInfo(m_vTables[ii]) );
                xsMessage.Append( sDatabaseUpdateTables(ii,xDateAnchor, bUpdateOnlyMissing) );
            }
        }
        
        wxMessageBox(xsMessage, wxT("Update completed"));
        
    }
}





/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_SEARCH
 */

void CrumbsViewer_Frame::OnCrumbsButtonSearchClick( wxCommandEvent& event )
{
    ////@begin wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_SEARCH in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
    ////@end wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_SEARCH in CrumbsViewer_Frame.
    
    
    vSearchNow(true);
   

}

wxString CrumbsViewer_Frame::sDatabaseUpdateTables(int nTableIndex, wxDateTime & xDateAnchor, bool bOnlyMissing)
{
    bool bShowProgress = true;
    
    wxString xsMessageReturn;
    //get option
    
    //check if table exists, if not, create it!
    CVTable * pTable = pGetTable(nTableIndex);
    
    if(pTable!= NULL)
    {
        
        sqlite3 *mydb;
        char * zErrMsg = 0;
        int rc;
        
        //open the DB (or create it!)
        std::string sDBName = std::string( m_xsDatabaseFileName.mbc_str());
        rc = sqlite3_open(sDBName.c_str(), &mydb);
        
        if(rc)
        {
            wxString xsMessage = wxString::Format(wxT("Error Opening database %s"), sqlite3_errmsg(mydb));
            wxMessageBox(xsMessage);
            //        printf("Error opening database %s\n", sqlite3_errmsg(mydb));
            sqlite3_close(mydb);
        }
        else
        {
            
            long t1, t2, t3;
            wxStopWatch sw1, sw2, sw3;
            
            sw1.Start();
            wxString xsSql = wxString::Format(wxT("CREATE VIRTUAL TABLE IF NOT EXISTS %s USING fts4") \
                                              wxT("(ID INT PRIMARY KEY     NOT NULL,")\
                                              wxT("FILENAME   TEXT    NOT NULL,") \
                                              wxT("PLAINTEXT TEXT    NOT NULL);"),pTable->xsDBTable.mb_str() );
            
            /* Execute SQL statement */
            rc = sqlite3_exec(mydb, xsSql.c_str(), sqlite_callback, 0, &zErrMsg);
            if( rc != SQLITE_OK )
            {
                fprintf(stderr, "SQL error: %s\n", zErrMsg);
                sqlite3_free(zErrMsg);
            }else{
                fprintf(stdout, "Table created successfully\n");
            }
            t1 = sw1.Time();
            //NOW, iterate and introduce all contents of text files
            
            
            
            int nStart = pTable->m_nDocumentFirst;
            int nStop = pTable->m_nDocumentLast;
            
            wxString xsUpdateCaption = wxString::Format(wxT("Updating table: %s"),pTable->xsTableName.mb_str() );
            
            wxProgressDialog *progressDLG = NULL;
            if (bShowProgress) {
                progressDLG = new wxProgressDialog(xsUpdateCaption,wxT("Starting update...                                "),100,this, wxPD_APP_MODAL  );
            }
            
            //experiment with prepared statements.
            wxString xsSqlPrepared = wxString::Format(wxT("SELECT ROWID FROM %s WHERE ID=?"),pTable->xsDBTable.mb_str());
            
            sqlite3_stmt *prepared_stmt;
            
            sw2.Start();
            
            sqlite3_prepare_v2(mydb, xsSqlPrepared.c_str(), -1, &prepared_stmt, NULL);
            t2 = sw2.Time();
            
            int nTotalFiles = nStop-nStart+1;
            int nCount = 0;
            
            int nTotalAdded = 0;
            int nTotalUpdated = 0;
            int nTotalSkipped = 0;
            int nTotalErrors = 0;
            // for(int ii = pTable->m_nDocumentFirst; ii<pTable->m_nDocumentLast; ii++)
            
            sw3.Start();
            for(int ii = nStart; ii<=nStop; ii++)
            {
                //add the first 100 to the database
                
                int nProgressValue=(100.0*nCount)/(nTotalFiles);
                
                if (ii%100 == 0) {
                    printf("Processing file: %d / %d  (%d%%)\n", ii,nTotalFiles, nProgressValue);
                    if (bShowProgress) {
                        progressDLG->Update(nProgressValue,wxString::Format(wxT("File %d/%d"),ii, nTotalFiles));
                    }
                }
                
                file_element *pFileElement = pTable->pGetFileInfoTXT(ii);
                
                if(pFileElement != NULL && pFileElement->sFullPath.size() > 0)
                {
                    
                    wxString xsFileName = wxString(pFileElement->sFullPath.c_str(), wxConvUTF8);
                    //open the text file, then clean it up!
                    //kk wxFile tMyFile(xsFileName,wxFile::read);
                    
                    wxFileName xFN(xsFileName);
                    
                    wxDateTime xDateFile = xFN.GetModificationTime();
                    
                    
//                    if(tMyFile.IsOpened())
                    if(xFN.Exists())
                    {
                        
                        if(xDateFile.IsLaterThan(xDateAnchor) )
                        {
                            
                            //USING PREPARED STATEMENT.
                            sqlite3_bind_int(prepared_stmt, 1, ii);
                            
                            ///check if ID exists, if it does, update, if not, create
                            rc = SQLITE_ROW;
                            
                            int nRecordsFound = 0;
                            while(rc == SQLITE_ROW)
                            {
                                
                                rc = sqlite3_step(prepared_stmt);
                                
                                if(rc == SQLITE_ROW )
                                {
                                    nRecordsFound++;
                                }
                                else if(rc == SQLITE_DONE)
                                {
                                    rc = SQLITE_OK;
                                    break;
                                }
                                
                                
                            }
                            
                            sqlite3_reset(prepared_stmt);
                            
                            bool bUpdated = false;
                            bool bCreated = false;
                            if(rc == SQLITE_OK )
                            {
                                //printf("  records found = %d, rc=%d\n",nRecordsFound, rc);
                                if(nRecordsFound == 0)
                                {// append
                                    
                                    
                                    wxString xsFileContents;
                                    wxFile tMyFile(xsFileName,wxFile::read);
                                    if(tMyFile.IsOpened())
                                    {
                                        
                                        tMyFile.ReadAll(&xsFileContents);
                                        
                                        //cleanup stuff
                                        xsFileContents.Replace(wxT("'"), wxT("''"));
                                        
                                        //close the file
                                        tMyFile.Close();
                                        
                                        xsSql = wxString::Format(wxT("INSERT INTO %s(ID,FILENAME,PLAINTEXT) ")  \
                                                                 wxT("VALUES ( %d, '%s', '%s' );"),
                                                                 pTable->xsDBTable.mb_str(),
                                                                 ii,
                                                                 pFileElement->sName.c_str(),
                                                                 xsFileContents.mb_str());
                                        
                                        
                                        
                                        
                                        /* Execute SQL statement */
                                        rc = sqlite3_exec(mydb, xsSql.c_str(), sqlite_callback, 0, &zErrMsg);
                                        
                                        bCreated = true;
                                    }
                                    else
                                    {
                                        printf("Problem reading %s\n",(const char*)xsFileName.mb_str());
                                    }
                                    
                                }
                                else
                                {
                                    //update
                                    
                                    //first check if it has more than 1 record
                                    if(nRecordsFound>1)
                                    {
                                        printf(" Deleting %d rows\n", nRecordsFound-1);
                                        //select ID
                                        xsSql = wxString::Format(wxT("delete from %s where ROWID in (select ROWID from %s where ID=%d order by ROWID desc limit %d);"),pTable->xsDBTable.mb_str(),pTable->xsDBTable.mb_str(), ii, nRecordsFound-1);
                                        
                                        rc = sqlite3_exec(mydb, xsSql.c_str(), sqlite_callback, 0, &zErrMsg);
                                        if( rc != SQLITE_OK )
                                        {
                                            fprintf(stderr, "SQL error Deleting (%d): %s\n",rc, zErrMsg);
                                            sqlite3_free(zErrMsg);
                                            
                                        }
                                        
                                        //delete some
                                    }
                                    
                                    
                                    //if( rc == SQLITE_CONSTRAINT && zErrMsg[0]=='U' && zErrMsg[1] == 'N')
                                    if(bOnlyMissing == false)
                                    {
                                        //not very robust, but works
                                        //error inserting then, update it instead!
                                        
                                        wxString xsFileContents;
                                        wxFile tMyFile(xsFileName,wxFile::read);
                                        if(tMyFile.IsOpened())
                                        {
                                            
                                            tMyFile.ReadAll(&xsFileContents);
                                            
                                            //cleanup stuff
                                            xsFileContents.Replace(wxT("'"), wxT("''"));
                                            
                                            //close the file
                                            tMyFile.Close();
                                            
                                            
                                            xsSql = wxString::Format(wxT("UPDATE %s SET FILENAME = '%s',PLAINTEXT = '%s' WHERE ID =%d;"),
                                                                     pTable->xsDBTable.mb_str(),
                                                                     pFileElement->sName.c_str(),
                                                                     xsFileContents.mb_str(),
                                                                     ii);
                                            
                                            
                                            
                                            
                                            /* Execute SQL statement */
                                            rc = sqlite3_exec(mydb, xsSql.c_str(), sqlite_callback, 0, &zErrMsg);
                                            bUpdated = true;
                                        }
                                        else
                                        {
                                            printf("Problem reading %s\n",(const char*)xsFileName.mb_str());
                                        }
                                        
                                    }
                                    else
                                    {
                                        printf(" no update needed\n");
                                        nTotalSkipped++;
                                    }
                                } //append or update
                            }
                            
                            if( rc != SQLITE_OK )
                            {
                                printf("SQL error (%d): %s\n",rc, zErrMsg);
                                sqlite3_free(zErrMsg);
                                nTotalErrors++;
                            }
                            else
                            {
                                if(bUpdated)
                                {
                                    //printf("Records updated successfully\n");
                                    nTotalUpdated++;
                                }
                                
                                if(bCreated)
                                {
                                    //printf("Records created successfully\n");
                                    nTotalAdded++;
                                }
                            }
                        }//time test
                        else
                        {
                            printf("skipped (time test)\n");
                            nTotalSkipped++;
                        }
                    } //file exists
                    else
                    {
                        printf("File does not exists\n");
                        nTotalSkipped++;
                        
                    }
                    
                } //file element valid
                
                nCount++;
                
            } //iterate
            
            t3 = sw3.Time();
            
            sqlite3_finalize(prepared_stmt);
            
            printf("\ntime processing t1:%ld  t2:%ld  t3:%ld\n", t1, t2, t3);
            
            
            if (bShowProgress && progressDLG != NULL) {
                delete  progressDLG;
            }
            
            xsMessageReturn = wxString::Format(wxT("Table updated : %s\n") \
                                                     wxT("Files Added   : %d\n") \
                                                     wxT("Files updated : %d\n") \
                                                     wxT("Files skipped : %d\n") \
                                                     wxT("Files errors  : %d\n"), pTable->xsTableName.mb_str(), nTotalAdded, nTotalUpdated, nTotalSkipped, nTotalErrors );
            //wxMessageBox(xsStatistics, wxT("Update completed"));
            
            
            
            
            //close the DB
            sqlite3_close(mydb);
        }
        
    }// ptable not null
    
    return xsMessageReturn;
}







void CrumbsViewer_Frame::vDatabasePerformSearch(wxString &xsSearchString, int nTableIndex, int nLimit, CVCollection &tCollectionResults)
{
    //get option
    CVTable * pTable = pGetTable(nTableIndex);
    
    if(pTable!= NULL)
    {
        
        sqlite3 *mydb;
        char * zErrMsg = 0;
        int rc;
        
        //open the DB (or create it!)
        std::string sDBName = std::string( m_xsDatabaseFileName.mbc_str());
        rc = sqlite3_open(sDBName.c_str(), &mydb);
        
        if(rc)
        {
            wxString xsMessage = wxString::Format(wxT("Error Opening database %s"), sqlite3_errmsg(mydb));
            wxMessageBox(xsMessage);
            //        printf("Error opening database %s\n", sqlite3_errmsg(mydb));
            sqlite3_close(mydb);
        }
        else
        {
            
            //get string
            //sanitize string
            //do search
            //display results, do something with results!
            
            //wxString xsSearchString = m_textcontrolSearch->GetValue();
            
            wchar_t wcSimpleQuote = wchar_t('\"');
            wchar_t wcTypoQuoteLeft = 0x201C;
            wchar_t wcTypoQuoteRight = 0x201D;
            
            //xsSearchString.Replace(wcTypoQuoteLeft, wcSimpleQuote);
            
            //first, replace weird quoutes.
            for(int ii=0; ii<xsSearchString.size(); ii++)
            {
                if(xsSearchString[ii] == wcTypoQuoteLeft || xsSearchString[ii] == wcTypoQuoteRight)
                    xsSearchString[ii] = wcSimpleQuote;
                
            }

            xsSearchString.Replace(wxT("'"), wxT("''"));
            
            wxString xsTableIndex = wxString::Format(wxT("%s"),pTable->xsDBTable.c_str());
            wxString xsFriendlyName = wxString::Format(wxT("%s"), pTable->xsTableName.c_str());
            
            wxString xsLimit;
            if(nLimit != -1)
            {
                xsLimit = wxString::Format(wxT("LIMIT %d"),nLimit);
            }
            
            wxString xsSql = wxString::Format(wxT("SELECT * FROM %s WHERE PLAINTEXT MATCH '%s' %s;"),xsTableIndex.mb_str() ,xsSearchString.mb_str(),xsLimit.mb_str() );
            
            
            /* Execute SQL statement */
            rc = sqlite3_exec(mydb, xsSql.c_str(), sqlite_callback_collection, &tCollectionResults, &zErrMsg);
            if( rc != SQLITE_OK )
            {
                fprintf(stderr, "SQL error: %s\n", zErrMsg);
                wxString xsMessage = wxString::Format(wxT("SQL error: %s"), zErrMsg);
                wxMessageBox(xsMessage);
                sqlite3_free(zErrMsg);
            }else{
                fprintf(stdout, "Search completed successfully\n");
            }
            
            //NOW, iterate and introduce all contents of text files
            tCollectionResults.bSetTableTo(nTableIndex,true);
            
           
            
            
            wxString xsCollectionComments = wxString::Format(wxT("Search on %s for '%s' found %d records\n"),xsFriendlyName.mb_str() ,xsSearchString.mb_str(), tCollectionResults.nGetSize());
            tCollectionResults.m_sComment.append(std::string(xsCollectionComments.mb_str()));
            
            
            
            //close the DB
            sqlite3_close(mydb);
        }
        
    }// ptable not null
    
}

void CrumbsViewer_Frame::vDatabaseCreateUpdatePackage(wxString &xsFileName, wxArrayString &tAllFiles)
{
    printf(" Creating Update %s, for %ld files\n", (const char *)xsFileName.mb_str(), tAllFiles.size() );
    
    int nFileCount = tAllFiles.size();
    
    
    if(nFileCount>0)
    {
        
        sqlite3 *mydb;
        char * zErrMsg = 0;
        int rc;
        
        //open the DB (or create it!)
        std::string sDBName = std::string( xsFileName.mbc_str());
        rc = sqlite3_open(sDBName.c_str(), &mydb);
        
        if(rc)
        {
            wxString xsMessage = wxString::Format(wxT("Error Opening database %s"), sqlite3_errmsg(mydb));
            wxMessageBox(xsMessage);
            //        printf("Error opening database %s\n", sqlite3_errmsg(mydb));
            sqlite3_close(mydb);
        }
        else
        {
            
            
            
            wxString xsSql = wxString::Format(wxT("CREATE TABLE IF NOT EXISTS CRUMBS_UPDATE") \
                                              wxT("(ID INT PRIMARY KEY     NOT NULL,")\
                                              wxT("FILEPATH   TEXT    NOT NULL,") \
                                              wxT("DATA       BLOB    NOT NULL);") );
            
            /* Execute SQL statement */
            rc = sqlite3_exec(mydb, xsSql.c_str(), sqlite_callback, 0, &zErrMsg);
            if( rc != SQLITE_OK )
            {
                fprintf(stderr, "SQL error: %s\n", zErrMsg);
                sqlite3_free(zErrMsg);
            }else{
                fprintf(stdout, "Table created successfully\n");
            }
            
            //NOW, iterate and introduce all contents of text files
            
            
            
            wxString xsUpdateCaption = wxString::Format(wxT("Creating Update Package"));
            wxProgressDialog *progressDLG = new wxProgressDialog(xsUpdateCaption,wxT("Starting package...                                "),100,this, wxPD_APP_MODAL | wxPD_AUTO_HIDE );
            
           
            int nCount = 0;
            
            int nTotalAdded = 0;
            int nTotalErrors = 0;
            // for(int ii = pTable->m_nDocumentFirst; ii<pTable->m_nDocumentLast; ii++)
            for(int ii = 0; ii<nFileCount; ii++)
            {
                //add the first 100 to the database
                
                printf("Processing file: %d/%d", ii+1, nFileCount);
                int nProgressValue=0.5+(100.0*nCount)/nFileCount;
                progressDLG->Update(nProgressValue,wxString::Format(wxT("File %d/%d"),ii+1,nFileCount));
                
                //Open file, as blob.
                //if open ok,  figure out how to insert the id, path and blob!
                
                std::string sFileName = std::string(tAllFiles[ii].mb_str() );
                std::ifstream tInFile;
                
                tInFile.open(sFileName.c_str(), std::ios::in | std::ios::binary);
                
                wxFileName xFile( tAllFiles[ii] );
                xFile.MakeRelativeTo(m_xsProgramPath);

                
                
                if(tInFile.is_open())
                {
                    //get length
                    tInFile.seekg(0, std::ifstream::end);
                    std::streampos file_size = tInFile.tellg();
                    tInFile.seekg(0);
                    
                    
                    //read the whole file!
                    char * buffer = new char[file_size];
                    tInFile.read(buffer, file_size);//read the whole file!
                    
                    //insert sucker
                    {
                        sqlite3_stmt * stmt = NULL;
                        
                        wxString xsSql = wxString::Format(wxT("INSERT INTO CRUMBS_UPDATE(ID,FILEPATH,DATA)") \
                                                          wxT("VALUES(%d, '%s', ?);"),ii,xFile.GetFullPath().mb_str() );
                        

                        
                        rc = sqlite3_prepare_v2(mydb, xsSql.c_str(), -1, &stmt, NULL);
                        
                        if(rc != SQLITE_OK)
                        {
                            fprintf(stderr, "SQL error creating statement: %s\n", sqlite3_errmsg(mydb));
                            nTotalErrors++;
                        }
                        else
                        {
                            
                            rc = sqlite3_bind_blob(stmt, 1, buffer, (int)file_size, SQLITE_STATIC); //SQLITE_TRANSIENT maybe ok to be static for now.
                            
                            if(rc != SQLITE_OK)
                            {
                                fprintf(stderr, "SQL error binding blob : %s\n", sqlite3_errmsg(mydb));
                                nTotalErrors++;
                            }
                            else
                            {
                                rc = sqlite3_step(stmt);
                                if(rc != SQLITE_DONE)
                                {
                                    fprintf(stderr, "SQL error saving blob: %s\n", sqlite3_errmsg(mydb));
                                    nTotalErrors++;
                                    
                                }
                                else
                                {
                                    //all worked!
                                    nTotalAdded++;
                                }
                            }
                        }
                        sqlite3_finalize(stmt);
                        
                    }//end inserting file
                    
                    delete [] buffer;
                    tInFile.close();
                }//file opened
                
                
                
            
                

                nCount++;
                
            } //iterate
            
            
            delete  progressDLG;
            
            wxString xsStatistics = wxString::Format(wxT("Update Package created  : %s\n") \
                                                     wxT("Files Added   : %d\n") \
                                                     wxT("Files errors  : %d"), xsFileName.mb_str(), nTotalAdded, nTotalErrors );
            wxMessageBox(xsStatistics, wxT("Update Package completed"));
            
            
            
            
            //close the DB
            sqlite3_close(mydb);
        }
        
    }
    
}

wxString CrumbsViewer_Frame::sDatabaseApplyUpdatePackage(wxString &xsFileName, wxString & xsBasePath)
{
    printf("Updating from %s\n", (const char*)xsFileName.mb_str());
	printf("base path %s\n", (const char*)xsBasePath.mb_str());
    
    wxString xsMessageReturn;
    
    
    sqlite3 *mydb;
    char * zErrMsg = 0;
    int rc;
    
    //open the DB
    std::string sDBName = std::string( xsFileName.mbc_str());
    rc = sqlite3_open(sDBName.c_str(), &mydb);
    
    if(rc)
    {
        wxString xsMessage = wxString::Format(wxT("Error Opening database %s"), sqlite3_errmsg(mydb));
        wxMessageBox(xsMessage);

        sqlite3_close(mydb);
    }
    else
    {
        
        wxString xsSql = wxString::Format(wxT("SELECT count(*) FROM CRUMBS_UPDATE;") );
        
        int nFilesCount = 0;
        /* Execute SQL statement */
        rc = sqlite3_exec(mydb, xsSql.c_str(), sqlite_callback_getinteger, &nFilesCount, &zErrMsg);
        if( rc != SQLITE_OK )
        {
            fprintf(stderr, "SQL error: %s\n", zErrMsg);
            sqlite3_free(zErrMsg);
        }else{
            fprintf(stdout, "Rows computed successfully\n");
            
        }
        
        printf("Got %d files to process\n",nFilesCount);
        
        //ask for base path to upate files to??  use program path as base.
        
        
        int nTotalProcessed = 0;
        int nTotalErrors = 0;
        if(nFilesCount > 0 )
        {
            wxString xsUpdateCaption = wxString::Format(wxT("Applying Update Package"));
            wxProgressDialog *progressDLG = new wxProgressDialog(xsUpdateCaption,wxT("Starting update...                                "),100,this, wxPD_APP_MODAL | wxPD_AUTO_HIDE );

            
            for(int ii=0; ii<nFilesCount; ii++)
            {
                
               // printf("Processing file: %d/%d", ii+1, nFilesCount);
                int nProgressValue=0.5+(100.0*ii)/nFilesCount;
                progressDLG->Update(nProgressValue,wxString::Format(wxT("File %d/%d"),ii+1,nFilesCount));
                
                //get blob per row,
                // check if folder path exists, if not, create
                // go and create file (folder if neccesary)
                // create file
                
                sqlite3_stmt * stmt = NULL;
                
                wxString xsSql = wxString::Format(wxT("SELECT FILEPATH,DATA FROM CRUMBS_UPDATE WHERE ID=%d;"),ii );
                
                
                
                rc = sqlite3_prepare_v2(mydb, xsSql.c_str(), -1, &stmt, NULL);
                
                if(rc != SQLITE_OK)
                {
                    fprintf(stderr, "SQL error creating statement: %s\n", sqlite3_errmsg(mydb));
                    nTotalErrors++;
                }
                else
                {
                    if(sqlite3_step(stmt) == SQLITE_ROW)
                    {
                        std::string sFile = (char*)sqlite3_column_text(stmt, 0);
                        //yes.. we might use the prepared statement
                        int len = sqlite3_column_bytes(stmt, 1);
                        
                        printf("%d. %s, file size %d bytes\n",ii,sFile.c_str(), len);
                        
                        char * buffer = new char[len];
                        //read bytes
                        memcpy(buffer, sqlite3_column_blob(stmt, 1), len);
                        
                    
                        //create full path.
                        //check if exists.
                        //
                        
                        //create fullFileName
                        wxString xsFullFileName = xsBasePath +wxFILE_SEP_PATH + wxString(sFile.c_str(), wxConvUTF8);
                        printf(" full filename: %s\n", (const char *)xsFullFileName.mb_str());
                    
                        wxFileName xFile( xsFullFileName );
                        wxFileName xPath(xFile.GetPath(wxPATH_GET_VOLUME | wxPATH_GET_SEPARATOR));
                        bool bContinue = true;
                        
                        printf(" full path: %s\n", (const char *) xPath.GetPath(wxPATH_GET_SEPARATOR).mb_str());
                        //test directory
                        if(!xPath.DirExists())
                        {
                            //need to create directory!
                            bContinue = xPath.Mkdir(wxS_DIR_DEFAULT, wxPATH_MKDIR_FULL);
                            if(bContinue)
                                printf("directory created %s\n", (const char *)xPath.GetPath().mb_str() );
                            else
                                printf("Error creating directory %s\n", (const char *)xPath.GetPath().mb_str() );
                        }
                        
                        if(bContinue)
                        {
                            //open file for writing
                            
                            std::ofstream tOutFile;
                            
                            tOutFile.open((const char *)xsFullFileName.mb_str(), std::ios::out| std::ios::binary);
                            
                            
                            
                            
                            if(tOutFile.is_open())
                            {
                                tOutFile.write(buffer, len);
                                
                                tOutFile.close();
                                nTotalProcessed++;
                            }
                            else
                            {
                                nTotalErrors++;
                            }
                            
                            
                            
                            
                        }
                        else
                        {
                            nTotalErrors++;
                        }
       

                        delete [] buffer;
                        
                    }
                    else
                    {
                        nTotalErrors++;
                    }
                        
                
                }//prepared statement
                sqlite3_finalize(stmt);
                
                
            }//all files iteration
            
            delete  progressDLG;

            
        } //if filescount > 0
        
        xsMessageReturn = wxString::Format(wxT("------------\nUpdate Package applied  : %s\n") \
                                                 wxT("Files Added   : %d\n") \
                                                 wxT("Files errors  : %d\n--------------\n"), xsFileName.mb_str(), nTotalProcessed, nTotalErrors );
        //wxMessageBox(xsStatistics, wxT("Update Package completed"));
        
        //notify that package was installed in ini file.
        {
            vIniFileAppendUpdatePackage(INI_FILE, xsFileName );
        
        }
        

        //close the DB
        sqlite3_close(mydb);
    }
    
    
    return xsMessageReturn;
    
    
}




/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_CLEAR_SEARCH
 */

void CrumbsViewer_Frame::OnCrumbsButtonClearSearchClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_CLEAR_SEARCH in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_CLEAR_SEARCH in CrumbsViewer_Frame.
    m_textcontrolSearch->Clear();
}


void CrumbsViewer_Frame::vRefreshSearchResults()
{
    if(m_listboxResults != NULL)
    {
        m_listboxResults->Clear();
        
        int nCount = (int)m_tCollectionResults.m_vItems.size();
        
        for(int ii = 0; ii<nCount; ii++)
        {
            long lIndex = m_tCollectionResults.m_vItems[ii].lIndex;
            int nTable =  m_tCollectionResults.m_vItems[ii].nTable;
            
            CVTable *pTable =  pGetTable(nTable);
            wxString xsTableName = wxT("---");
            if(pTable != NULL)
            {
                xsTableName = pTable->xsTableName;
            }
            
            wxString xsTemp =wxString::Format(wxT("%d. %s | %ld"),ii,xsTableName.mb_str(), lIndex);
            
            m_listboxResults->Append(xsTemp);
        }
        
        if(nCount>0)
        {
            m_listboxResults->SetSelection(0);
            m_listboxResults->EnsureVisible(0);
            
            vSetNewPage(m_tCollectionResults.m_vItems[0].nTable, m_tCollectionResults.m_vItems[0].lIndex);
        }
        
        m_textctrlCollectionComment->SetValue( wxString(m_tCollectionResults.m_sComment.c_str(), wxConvUTF8));
        
        //now, select item N
    }
    
}


/*
 * wxEVT_COMMAND_LISTBOX_SELECTED event handler for ID_CRUMBS_LISTBOX_COLLECTION
 */

void CrumbsViewer_Frame::OnCrumbsListboxCollectionSelected( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_LISTBOX_SELECTED event handler for ID_CRUMBS_LISTBOX_COLLECTION in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_LISTBOX_SELECTED event handler for ID_CRUMBS_LISTBOX_COLLECTION in CrumbsViewer_Frame.
    
    int nSel = event.GetSelection();
    //switch to
    
//    collection_item *pItem = m_tCollectionResults.pGetItem(nSel);
//    if(pItem != NULL)
//    {
//        vSetNewPage(pItem->nTable, pItem->lIndex);
//    }
//
//
    vSelectResult(nSel, false); //absolute!
}


void CrumbsViewer_Frame::vSelectResult( int nResultIndex, bool bRelative )
{
    int nIndex = nResultIndex;
    if(bRelative)
    {
        int nCurrentIndex = m_listboxResults->GetSelection();
        nIndex  = nCurrentIndex + nResultIndex;
        
    }
    
    
    collection_item *pItem = m_tCollectionResults.pGetItem(nIndex);
    if(pItem != NULL)
    {
        m_listboxResults->SetSelection(nIndex);
        m_listboxResults->EnsureVisible(nIndex);
        vSetNewPage(pItem->nTable, pItem->lIndex);
    }
    
}



/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_RESULTS_FIRST
 */

void CrumbsViewer_Frame::OnCrumbsButtonResultsFirstClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_RESULTS_FIRST in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_RESULTS_FIRST in CrumbsViewer_Frame.
    vSelectResult(0, false);
}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_RESULTS_PREV
 */

void CrumbsViewer_Frame::OnCrumbsButtonResultsPrevClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_RESULTS_PREV in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_RESULTS_PREV in CrumbsViewer_Frame.
    
    vSelectResult(-1, true);
}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_RESULTS_NEXT
 */

void CrumbsViewer_Frame::OnCrumbsButtonResultsNextClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_RESULTS_NEXT in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_RESULTS_NEXT in CrumbsViewer_Frame.
    
    vSelectResult(1, true);
}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_RESULTS_LAST
 */

void CrumbsViewer_Frame::OnCrumbsButtonResultsLastClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_RESULTS_LAST in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_RESULTS_LAST in CrumbsViewer_Frame.
    
    int nLast = m_tCollectionResults.m_vItems.size()-1;
    vSelectResult(nLast, false);
}


/*
 * wxEVT_COMMAND_COMBOBOX_SELECTED event handler for ID_CRUMBS_COMBO_PREVIOUS_SEARCH
 */

void CrumbsViewer_Frame::OnCrumbsComboPreviousSearchSelected( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_COMBOBOX_SELECTED event handler for ID_CRUMBS_COMBO_PREVIOUS_SEARCH in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_COMBOBOX_SELECTED event handler for ID_CRUMBS_COMBO_PREVIOUS_SEARCH in CrumbsViewer_Frame.
    
    
    wxString xsPreviousSearch = event.GetString();
    
    m_textcontrolSearch->SetValue(xsPreviousSearch);
    
    vSearchNow(false);
    
    //fake the search button call?
}

void CrumbsViewer_Frame::vSearchNow(bool bUpdateHistory)
{
    int nLimit = -1; //all
    int nLimitIndex = m_comboSearchLimit->GetSelection();
    switch(nLimitIndex)
    {
        case 0: nLimit = 10; break;
        case 1: nLimit = 100; break;
        case 2: nLimit = 500; break;
    }
    
    wxString xsSearchString = m_textcontrolSearch->GetValue();
    
    if(xsSearchString.size()> 0)
    {
//        int nTableIndex = m_comboSearchDB->GetSelection();
        m_tCollectionResults.vClear();
//        if(nTableIndex < m_vTables.size() )
//        {
//            vDatabasePerformSearch(xsSearchString, nTableIndex, nLimit, m_tCollectionResults);
//        }
//        else
//        {   //search in all tables!
//            for(int ii=0; ii<m_vTables.size(); ii++)
//            {
//                vDatabasePerformSearch(xsSearchString, ii, nLimit, m_tCollectionResults);
//            }
//            
//        }

        
        for(int ii=0; ii<m_vTables.size(); ii++)
        {  // is selected?
            if (m_checkListBoxSearchDB->IsChecked(ii)) {
                vDatabasePerformSearch(xsSearchString, ii, nLimit, m_tCollectionResults);
            }
        }
        printf("\n\n Collection results :%d\n", (int)m_tCollectionResults.m_vItems.size());
        
        vRefreshSearchResults();
        
        //append previous search to the combo box
        if(bUpdateHistory)
        {
            m_comboPreviousSearch->Insert(xsSearchString, 0); //as first item!
            m_comboPreviousSearch->SetSelection(0); //always on first item
        }
    }// search string > 0
}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_TEST
 */

void CrumbsViewer_Frame::OnCrumbsButtonTestClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_TEST in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_TEST in CrumbsViewer_Frame.
    
//    wxString xsLastSearchTerm = m_textcontrolSearch->GetValue();
//    //highlight last search term if possible
//    long lResult= m_webDocument->Find(xsLastSearchTerm, wxWEBVIEW_FIND_HIGHLIGHT_RESULT );
//    printf("Search result in web: %ld\n", lResult);
//    
//
//    wxString xsSelectedText = m_webDocument->GetSelectedText();
//    
//    printf("Selected text %s\n",(const char *)xsSelectedText.mb_str(wxConvUTF8) );
    
    printf(" Collection: \n%s", m_tCollectionResults.sToString().c_str());
    
}


void CrumbsViewer_Frame::vSetCollection(CVCollection &tCollection)
{
    m_tCollectionResults.vClear();
    m_tCollectionResults = tCollection;
    
   vRefreshSearchResults();
    
}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_SEARCH_HELP
 */

void CrumbsViewer_Frame::OnCrumbsButtonSearchHelpClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_SEARCH_HELP in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_SEARCH_HELP in CrumbsViewer_Frame.
    
    if(m_frameSearchHelp != NULL)
    {
        if(m_frameSearchHelp->IsShown())
        {
            m_frameSearchHelp->Show(false);
        }
        else
        {
            m_frameSearchHelp->Show(true);
        }
    }
}


/*
 * wxEVT_COMMAND_MENU_SELECTED event handler for ID_CRUMBS_MENU_DATABASE_CREATE_PACKAGE
 */

void CrumbsViewer_Frame::OnCrumbsMenuDatabaseCreatePackageClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_MENU_SELECTED event handler for ID_CRUMBS_MENU_DATABASE_CREATE_PACKAGE in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_MENU_SELECTED event handler for ID_CRUMBS_MENU_DATABASE_CREATE_PACKAGE in CrumbsViewer_Frame.
    
    wxArrayString tAllFiles;
    
    wxString xsCurrentPath = wxGetCwd();
    
    wxString xsPath = xsCurrentPath + wxFILE_SEP_PATH;
    
    
    
    bool bContinueAddingFiles = true;
    
    ///PDF Documents (*.pdf)|*.pdf|Text files (*.txt)|*.txt|
    while(bContinueAddingFiles)
    {
        
        wxArrayString dialogchoices;
        dialogchoices.Add(wxT("by files"));
        dialogchoices.Add(wxT("by folders (recursively)"));
        
        //add files or full...
        wxSingleChoiceDialog dir_file_dialog(this, wxT("Pick by files or folders(recursively)"), wxT("Pick by files or folders"),dialogchoices );
        
        if(dir_file_dialog.ShowModal() == wxID_OK)
        {
            int nSelection = dir_file_dialog.GetSelection();
            
            
            if(nSelection==0)
            {
                wxFileDialog dialog(this,wxT("choose files to include in your update package"),xsPath, wxEmptyString,
                                    wxT("All  files (*.*)|*.*"), wxFD_OPEN | wxFD_MULTIPLE);
                if(dialog.ShowModal() == wxID_OK )
                {
                    
                    ///show files// append to big list of files!
                    wxArrayString tFiles;
                    dialog.GetPaths(tFiles);
                    
                    for(int ii=0; ii<tFiles.size(); ii++)
                    {
                        
                        tAllFiles.Add( tFiles[ii]);
                    }
                }
            }
            else
            { //directory and all sub dirs
                wxDirDialog dirDialog(this,wxT("Choose folder"),xsPath, wxDD_DEFAULT_STYLE );
                
                if(dirDialog.ShowModal() == wxID_OK)
                {
                    wxString xsNewPath = dirDialog.GetPath();
                    //choose all files
                    
                    //go to start path, and create file list.
                    std::stringstream ss;
                    std::vector<file_element> vFiles;
                    
                    std::string sBasePath = xsNewPath.ToStdString();
                    std::string sExt; //none
                    bCreateFileListV2(ss, sBasePath, sExt, -1, vFiles);
                    
                    printf(" got %d files in here...\n", (int)vFiles.size());
                    
                    
                    for(int ii=0; ii<vFiles.size(); ii++)
                    {
                        wxString xsFullPath = wxString(vFiles[ii].sFullPath.c_str(), wxConvUTF8);
                        tAllFiles.Add( xsFullPath);
                    }
 
                }
            } //sub dirs
            
        }

        wxString xsMessage = wxString::Format(wxT("%d files on the list\nDo you want to add more files?"), (int)tAllFiles.size() );
        
        if (wxMessageBox(xsMessage, wxT("Please confirm"), wxICON_QUESTION | wxYES_NO) != wxYES )
        {
            bContinueAddingFiles = false;
        }
    }
    
    
    int nAllFileCount = (int)tAllFiles.GetCount();
    
    
    if(nAllFileCount>0)
    {
        //ask for a destination file (to create)
        
        wxDateTime t = wxDateTime::Now();
        
        wxString xsDateTime = t.Format(wxT("%Y%m%d"));//_%H%M%S"));//
        wxString xsDefaultUpdatePackageName = wxT("crumbs_update_")+xsDateTime+wxT(".cru");
        
        wxString xsMessage = wxString::Format(wxT("Create update package for %d files"), nAllFileCount);
        wxFileDialog save_dialog(this,xsMessage, xsPath, xsDefaultUpdatePackageName,
                            wxT("Crumbs Viewer Update Package (*.cru)|*.cru"), wxFD_SAVE | wxFD_OVERWRITE_PROMPT);
        
        if(save_dialog.ShowModal() == wxID_OK)
        {
            
            wxString sFullPath = save_dialog.GetPath();
            wxFileName xFileName = sFullPath;
            if(xFileName.HasExt() == false)
            {
                //append extension
                sFullPath.append(".cru");
            }
            
            
            //Now, create database and append blob files
            vDatabaseCreateUpdatePackage(sFullPath, tAllFiles);
            
        }
    }
    
}


/*
 * wxEVT_COMMAND_MENU_SELECTED event handler for ID_CRUMBS_MENU_DATABASE_LOAD_UPDATE
 */

void CrumbsViewer_Frame::OnCrumbsMenuDatabaseLoadUpdateClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_MENU_SELECTED event handler for ID_CRUMBS_MENU_DATABASE_LOAD_UPDATE in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_MENU_SELECTED event handler for ID_CRUMBS_MENU_DATABASE_LOAD_UPDATE in CrumbsViewer_Frame.
    
    wxString xsCurrentPath = wxGetCwd();
    wxString xsPath = xsCurrentPath + wxFILE_SEP_PATH;
    

    wxFileDialog dialog(this,wxT("Choose Update Package"),xsPath, wxEmptyString,
                        wxT("Crumbs Viewer Update Package (*.cru)|*.cru"), wxFD_OPEN );
    if(dialog.ShowModal() == wxID_OK )
    {
        ///show files// append to big list of files!
        wxString xsUpdateFile = dialog.GetPath();
        
        
        
        //ask for destination folder...
      //ee  wxDirDialog dirDialog(this,wxT("Choose root folder to apply update"),m_xsProgramPath, wxDD_DEFAULT_STYLE );
        
      //  if(dirDialog.ShowModal() == wxID_OK)
        {
            
            int nUpdateAnswer = wxMessageBox(wxT("Do you want to also update the database and tables?"), wxT("Please confirm"), wxICON_QUESTION | wxYES_NO);
            wxString xsNewPath = m_xsProgramPath;//dirDialog.GetPath();
            wxString xsMessage;
            
            //current system datetime, to update things created or modified AFTER THIS ONLY
            wxDateTime xDateNow = wxDateTime::Now();
        
            xsMessage.Append( sDatabaseApplyUpdatePackage(xsUpdateFile, xsNewPath) );
            
            
            if (nUpdateAnswer == wxYES )
            {
                
                for(int ii=0; ii<m_vTables.size(); ii++)
                {
                    xsMessage.Append( sUpdateTableInfo(m_vTables[ii]) );
                    xsMessage.Append(sDatabaseUpdateTables(ii,xDateNow, true) );
                }
            }
            
            wxMessageBox(xsMessage, wxT("Update completed"));
        }
    }
    
}

void CrumbsViewer_Frame::vCheckForLocalUpdates()
{
    
    //list local "cru" files
    // if any one of those hasn't been applied, ask to apply it.
    bool bAskToUpdateTables = false;
    
    wxDir xDir(m_xsProgramPath);
    wxString xsMessage;
    
    wxDateTime xDateAnchor = wxDateTime::Now();
    
    if( xDir.IsOpened() )
    {
        wxString xsFileName;
        //list the files here
        if(xDir.GetFirst(&xsFileName, wxT("*.cru"),wxDIR_FILES ) )
        {
            //got first
            //check to see if the
            
            do
            {
                printf("updates available: %s\n", (const char*) xsFileName);
                
                //check if that update has been applied
                if(nIniFileCheckUpdatePackageApplied(INI_FILE, xsFileName)>-1)
                {
                    //that update has been applied!
                    printf(" update has been applied already\n");
                }
                else
                {
                    //apply update!
                    wxString xMessage = wxString::Format(wxT("Update Package %s found, do you want to apply it?"), xsFileName);
                    if (wxMessageBox(xMessage, wxT("Please confirm"), wxICON_QUESTION | wxYES_NO) == wxYES )
                    {
                        printf(" Update should be applied\n");
                        
                        wxString xFullFileName = m_xsProgramPath + wxFILE_SEP_PATH +xsFileName;
                        xsMessage.Append( sDatabaseApplyUpdatePackage(xFullFileName, m_xsProgramPath) );
                        
                        bAskToUpdateTables = true;
                    }
                    
                }
                
            }
            while( xDir.GetNext(&xsFileName) );
            
        }
        
    }

    
    
    if(bAskToUpdateTables)
    {
        for(int ii=0; ii<m_vTables.size(); ii++)
        {
            xsMessage.Append( sUpdateTableInfo(m_vTables[ii]) );
            xsMessage.Append( sDatabaseUpdateTables(ii, xDateAnchor, true) );
        }
        
        
        wxMessageBox(xsMessage, wxT("Update completed"));
        
    }
    
    
}


/*
 * wxEVT_COMMAND_MENU_SELECTED event handler for wxID_ABOUT
 */

void CrumbsViewer_Frame::OnAboutClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_MENU_SELECTED event handler for wxID_ABOUT in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_MENU_SELECTED event handler for wxID_ABOUT in CrumbsViewer_Frame.
    
    
    wxAboutDialogInfo tInfo;
    
    wxString xsVersion = wxString::Format(wxT("%d.%d"),CRUMBS_VIEWER_VERSION_MAJOR, CRUMBS_VIEWER_VERSION_MINOR);
    
#ifdef __WXMAC__
    xsVersion.append(wxString::Format(wxT( " mac(%d)"), CRUMBS_VIEWER_VERSION_REVISION_MAC));
#else
    xsVersion.append(wxString::Format(wxT( " win(%d)"), CRUMBS_VIEWER_VERSION_REVISION_WIN));
#endif
    
    tInfo.SetName(wxT("Crumbs"));
    tInfo.SetVersion(xsVersion);
    tInfo.SetDescription(wxT("Document Viewer for searching and navigating large collections of documents"));
    
    
    tInfo.SetCopyright(wxT("\xa9 2013 - 2017 Ricardo Garcia @ragomusic @crumbssoftware"));
    
    tInfo.SetWebSite(wxT("http://crumbssoftware.com") );
    
    wxAboutBox(tInfo);

}


/*
 * wxEVT_COMMAND_MENU_SELECTED event handler for ID_MENUITEM_SEARCH_HELP
 */

void CrumbsViewer_Frame::OnMenuitemSearchHelpClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_MENU_SELECTED event handler for ID_MENUITEM_SEARCH_HELP in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_MENU_SELECTED event handler for ID_MENUITEM_SEARCH_HELP in CrumbsViewer_Frame.
    
    if(m_frameSearchHelp != NULL)
    {
        if(m_frameSearchHelp->IsShown())
        {
            m_frameSearchHelp->Show(false);
        }
        else
        {
            m_frameSearchHelp->Show(true);
        }
    }

}


/*
 * wxEVT_COMMAND_MENU_SELECTED event handler for ID_MENUITEM_FILETOOLS_LIST_CONSECUTIVE
 */

void CrumbsViewer_Frame::OnMenuitemFiletoolsListConsecutiveClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_MENU_SELECTED event handler for ID_MENUITEM_FILETOOLS_LIST_CONSECUTIVE in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_MENU_SELECTED event handler for ID_MENUITEM_FILETOOLS_LIST_CONSECUTIVE in CrumbsViewer_Frame.
    
    //ASK FOR A directory
    //ask for extension
    //ask for root
    
    //walk everything and create report.
    
    CVFileListTool  dialogFileList(this, wxID_ANY, wxT("File list consecutive analysis tool"));
    
    //configure
    dialogFileList.vSetPath(m_xsProgramPath);
    
    
    if(dialogFileList.ShowModal() == wxID_OK)
    {
        //proceed!
        
      
        
        wxString xsPrefix = dialogFileList.sGetPrefix();
        wxString xsPath = dialogFileList.sGetPath().mb_str();
        wxString xsExtension = dialogFileList.sGetExtension().mb_str();
        
        std::stringstream ss;
        std::vector<file_element> vFilesInput;
        
        std::string sBasePath = std::string(xsPath);
        std::string sExt = std::string(xsExtension);
        bCreateFileListV2(ss, sBasePath, sExt, -1, vFilesInput);
        
        
        //walk list
        
        long lMin = 1000000;
        long lMax = 0;
        // walk all,
        // remove the doc root and that  is the index!
        int nFileCount = (int)vFilesInput.size();
        for(int ii = 0; ii<nFileCount; ii++)
        {
            wxString xsFileName = wxString(vFilesInput[ii].sName.c_str(), wxConvUTF8);
            
            if(xsFileName.StartsWith(xsPrefix))
            {
                //remove n characters then get index number!
                wxString xsNumber = xsFileName.AfterFirst('0');
                long lValue;
                xsNumber.ToLong(&lValue);
                
                if(lValue < lMin)
                    lMin = lValue;
                
                if(lValue > lMax)
                    lMax = lValue;
                
            }
            
        }
        
        
        std::vector<file_element> vFilesSorted;
        //now, do a file array  in order in this table!
        
        vFilesSorted.resize(lMax+1);
        //now, walk again the list and assign to the right index!
        
        for(int ii = 0; ii<nFileCount; ii++)
        {
            wxString xsFileName = wxString(vFilesInput[ii].sName.c_str(), wxConvUTF8);
            
            if(xsFileName.StartsWith(xsPrefix))
            {
                //remove n characters then get index number!
                wxString xsNumber = xsFileName.AfterFirst('0');
                long lValue;
                xsNumber.ToLong(&lValue);
                
                
                if(lValue>=0 &&  lValue < vFilesSorted.size() )
                {
                    vFilesSorted[lValue] = vFilesInput[ii];
                }
            }
            
        }
        
        
        wxString xsMessage = wxString::Format( wxT(" path:   %s\n"), xsPath);
        xsMessage.Append(wxString::Format( wxT(" Ext:    %s\n"),xsExtension ));
        xsMessage.Append(wxString::Format( wxT(" Prefix: %s\n"), xsPrefix));
        xsMessage.Append(wxString::Format( wxT("   Min index: %ld\n"), lMin));
        xsMessage.Append(wxString::Format( wxT("   Max index: %ld\n"), lMax));
        xsMessage.Append(wxString::Format( wxT("  Total file count: %d\n"), nFileCount ));
        xsMessage.Append(wxString::Format( wxT("  --- Missing files\n") ));
        
        //find missing ones
        int nMissingFiles=0;
        for(long ii = lMin; ii<=lMax; ii++)
        {
            if(vFilesSorted[ii].sFullPath.size() == 0 || vFilesSorted[ii].sName.size() == 0)
            {
                nMissingFiles++;
                xsMessage.Append(wxString::Format( wxT("  Missing %ld\n"),ii));
            }
        }
        xsMessage.Append(wxString::Format( wxT(" ---\n total missing files: %d\n"), nMissingFiles ));
        
        //report
        
        wxMessageBox(xsMessage);

    }
    

    
}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_ALL_SEARCH_TABLES
 */

void CrumbsViewer_Frame::OnCrumbsButtonAllSearchTablesClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_ALL_SEARCH_TABLES in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_ALL_SEARCH_TABLES in CrumbsViewer_Frame.
    
    //Select all tables
    for(int ii=0; ii<m_vTables.size(); ii++) {
        m_checkListBoxSearchDB->Check(ii, true);
    }
}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_CLEAR_SEARCH_TABLES
 */

void CrumbsViewer_Frame::OnCrumbsButtonClearSearchTablesClick( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_CLEAR_SEARCH_TABLES in CrumbsViewer_Frame.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CRUMBS_BUTTON_CLEAR_SEARCH_TABLES in CrumbsViewer_Frame.
    
    //Select all tables
    for(int ii=0; ii<m_vTables.size(); ii++) {
        m_checkListBoxSearchDB->Check(ii, false);
    }
}

